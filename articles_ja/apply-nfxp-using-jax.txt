jaxを使ってNFXPアルゴリズムを実行してみる
2020-11-23

@p{NFXPアルゴリズムを調べると必ず出てくる論文}
@ul{J. Rust (1987), Optimal Replacement of GMC Bus Engines, Econometrica}
@p{の再現をしようと思ったが、この論文で使用しているデータが入手できなかったため、この記事で}
@ul{@a{Rust(1987)のデータを再現する}{@rel{/build/simulation-of-rust1987.html}}}
@p{そのデータをシミュレーションを使って再現してみるということを行った。}

@p{今回はその記事で生成したデータを使って、実際にNFXPアルゴリズムを動かしていきたい。}

@section{実装の方針}

@p{NFXPアルゴリズムは、以前の記事}
@ul{@a{NFXPアルゴリズムの簡単な応用例}{@rel{build/a-simple-application-of-nfxp-algorithm.html}}}
@p{にて説明した通り、あるパラメータの下でのエージェントの選択確率の推定と、そのパラメータ自体の最尤推定を交互に行うというアルゴリズムだった。}

@p{パラメータの推定を行う際の最尤推定はニュートン法を用いることになっていて、実際にそれを適用する際にはコスト関数の幾階かの微分の値が必要になる。コスト関数の表式もある程度複雑であり、実際に微分を手で計算して実装するのは骨が折れるため、今回自動微分に頼ることにした。自動微分を行うためのライブラリとしてはある程度自由度の高い@a{jaxライブラリ}{https://github.com/google/jax}を使用した。jaxを使うのは今回が初めてだったが、適当に簡単なlogistic回帰をnewton法で解く実装してみた感じ}
@ul{@a{jaxを使ってnewton法をする}{https://gist.github.com/Ktakuya332C/fcfdd70d278924151cc9df0549779f1e}}
@p{スムーズにかけたので採用した。}

@p{また自動微分を使う際には、コスト関数は微分する対象のパラメータについてのDAGになっていなければならないがそうなっていない。実際コスト関数@inmath{L}は次のように表されるが}
@blmath{
L = - \sum_{t=1}^T \ln P(i_t | x_t) - \sum_{t=1}^T \ln p(x_{t+1} | x_t, i_t)
}
@p{この選択確率@inmath{P}はベルマン作用素@inmath{\mathcal{B}}を用いた再帰的な式}
@blmath{\begin{aligned}
EV(x_k) &= \mathcal{B} EV(x_k) \\
&= \ln \left[ \sum_{i=0,1} \exp(u(x_k,i) + \beta \sum_{l=0}^{175} p(x_l | x_k, i) EV(x_l)) \right]
\end{aligned}}
@p{の不動点となる期待価値関数@inmath{EV}を用いて}
@blmath{
P(i|x_k) = \frac{\exp(u(x_k, i) + \beta \sum_{l=0}^{175} p(x_l | x_k, i) EV(x_l))}{\sum_{i=0,1} \exp(u(x_k, i) + \beta \sum_{l=0}^{175} p(x_l | x_k, i) EV(x_l))}
}
@p{と表現され、確かにDAGになっていない。実際に期待価値関数を計算する際には、適当なランダムな値@inmath{R}に対して適当な回数@inmath{K \ge 1}ベルマン作用素を適用させて近似的にその値を求めるため}
@blmath{
EV = \mathcal{B}^K R
}
@p{選択確率も同様にして}
@blmath{
P(i|x_k) = \frac{\exp(u(x_k, i) + \beta \sum_{l=0}^{175} p(x_l | x_k, i) \mathcal{B}^K R(x_l))}{\sum_{i=0,1} \exp(u(x_k, i) + \beta \sum_{l=0}^{175} p(x_l | x_k, i) \mathcal{B}^K R(x_l))}
}
@p{とすることでループを防ぎ、DAGにすることで自動微分を適用できるようにした。}


@section{実際の実装}

@p{実装したコードはgistにuploadしておいた。}
@ul{@a{jaxをつかってNFXPをやってみる}{https://gist.github.com/Ktakuya332C/e3c776513dd3e8d8eadac40cb90a919e}}

@p{実際にこのコードを動かしてみるとなにかしらコストが下がっている様子は見て取れるが、計算に時間がかかり最終的な結果をみるまでにかなり長い時間がかかりそうだったので、今のところ最後まで計算を終わらせたことがない。その影響もあってHessianを計算してその逆行列を取るなどのとても時間がかかるそうな作業を行うコードを実装に入れておらず、NFXPアルゴリズムとしてはまだ不完全なアルゴリズムである。}

@p{jaxにはjitコンパイルする機能もあり、それを入れてみて計算しようとしたところコンパイルが終わらずそもそも計算を始められなかったため、やはり無理やり不動点の計算をDAGにつけかえてしまった点が計算量が暴発する要因だったのだろうと考えられる。}


@section{備考}
@ul
  {今回のようにDAGに付け替えるような作業をしない限り手でhessianを無理やり計算するような作業を行うことになるのだが、NFXPアルゴリズムを使用する人たちはみんなそういう作業をやっているのだろうか?}
  {jaxは非常に使いやすいライブラリだったので、自動微分をしたいときには重宝しそうなライブラリだと感じた。}
